# dmod.core.context

The `dmod.core.context` package provides functionality needed to share important objects across processes.

## Overview

Objects may be shared across python processes by using an object manager to create
[proxies](https://en.wikipedia.org/wiki/Proxy_pattern) for objects. To the caller, these proxies (should) look and
act just like the objects they are proxies for. These objects are actually created in a server, thereby establishing a
method of [distributed object communication](https://en.wikipedia.org/wiki/Distributed_object_communication). Large
objects that contain data that needs to be shared may now exist within this other process with references calling said
objects from others.

This is performed by using Python's built in
[multiprocessing](https://docs.python.org/3.8/library/multiprocessing.html)
[Manager](https://docs.python.org/3.8/library/multiprocessing.html#managers) with several enhancements built
specifically for DMOD. Some of these enhancements are backports and fixes.

## Usage

Let's start by creating a basic object:

```python
import random

class SomeExample:
    def __init__(self):
        self.some_large_value = [random.uniform(0, 255) for _ in range(8000)]

    def do_something(self):
        ...

    def do_something_else(self):
        ...
```

I can "register" that new class to the `DMODObjectManager` simply by calling:

```python
from dmod.core.context import DMODObjectManager

DMODObjectManager.register_class(SomeExample)
```

That will add a reference to the new class _and_ generate a proxy class with support for fields like properties,
which isn't a well supported feature in the base implementation. The DMOD specific implementation has extra
utilities for generating proxies in order to get around a bug that won't be fixed until Python ~3.9.

A new proxy may now be created by calling:

```python
with DMODObjectManager() as manager:
    example: SomeExample = manager.create_object("SomeExample")
    example2: SomeExample = manager.SomeExample()
```

Both examples are valid, though directly calling `manager.SomeExample` may yield linting alerts due to the
dynamic nature of the manager. Note that the `DMODObjectManager` is used as a context object. Be sure to
_always_ use it this way. For better or worse, python's implementation of it performs special operations
on its `__enter__` and `__exit__` methods that would be troublesome to reproduce outside of that specific
workflow. Failing to use it this way may result in errors connecting to the server or errors when passing
objects between processes.

From there, `example` and `example2` may be used like a normal instance of `SomeExample` and they may be
passed to other processes via:

```python
with multiprocessing.Pool() as pool:
    pool.apply(some_function, kwargs={"example": example2});
```

_**If**_ this pattern cannot be used, it is indicative of a bug, not missing functionality. The `DMODObjectManager`
and its autogenerated proxies should be manageable without indepth knowledge.

### Gotchas

This section should be a running list of behavior that may complicate the process of using this functionality.

1. Managed objects **must** be created in the process that created the object manager
2. Closing the manager will kill all objects that were created, but not their proxies. Using a method on a proxy for
an object created via an object manager will result an an error
3. Object managers cannot be shared between processes
4. Any function that returns the object that owns the function **will** attempt to return the managed
object and _not_ the proxy. If the object is not pickleable, you will encounter an error. If it _is_ pickleable,
the resulting object will no longer update the shared instance.
5. Inputs and outputs to/from methods on these _must_ be pickleable. Inputs will be pickled and sent to the server
hosting the objects the results will be pickled and sent back to the process that called the function.

## Components

### dmod.core.context.base

Defines the abstract `ObjectManagerScope` class. Creating an object with an object manager within a nested function,
sending it to another process, and returning will destroy the managed object _within_ the server that the object
manager operates. When the receiving process attempts to use the proxy for the managed object an exception will be
thrown because it is no longer available within the object manager's server. That server keeps track of objects based
on reference counts from its proxies. When the scope of the function that created the object ends, the reference count
is decremented unless something retains the generated proxy. `ObjectManagerScope`s will hold on to references to
ensure that they are still available after the receiving process has gotten the chance to use it.

### dmod.core.context.manager

Defines the `DMODObjectManager` class. This is the **only** class that is needed in order to use this functionality.
Everything else are just implementation details. This is a custom implementation of the normal `BaseManager` that is
frequently used that avoids issues within the `BaseManager` present in older versions of Python (~3.8), allows the
caller to create proxies by name, maintains all functionality from the `BaseManager`, such as the ability to create
collections like lists and dictionaries, and keeps a scope manager that will keep items alive until told otherwise.

To use a `DMODObjectManager`'s scope, a scope must first be established. Given the instantiation:

```python
manager = DMODObjectManager()
```

call the following to create a new scope:

```python
import uuid

scope_id = uuid.uuid1()
new_scope: ObjectManagerScope = manager.establish_scope(scope_id)
```

This will create an internal scope bound to the `uuid` named `scope_id`. Now, the following can be called to create
objects within that scope:

```python
example: SomeExample = manager.create_object("SomeExample", scope_id)
example2: SomeExample = new_scope.create_object("SomeExample")
```

Both commands will create an object tied to the given scope. Calling:

```python
manager.free(scope_id)
```

will reduce the reference count on all objects in the scope. If nothing else is referencing the objects within the
scope, those objects will be destroyed. When the last of the living proxies that existed within that scope fall out of
use (such as by returning from a function that used it), those objects will be destroyed. Operations tied to other
processes may also be destroyed upon process completion by using the `DMODObjectManager`'s monitoring functionality.

Given:

```python
from concurrent.futures import ProcessPoolExecutor

def do_something_with_example(example: SomeExample):
    ...

executor = ProcessPoolExecutor()

future_result = executor.submit(do_something_with_example, example2)

new_scope.monitor(future_result)
```

Everything attached to `new_scope` will be freed when `future_result` is complete.

The `DMODObjectManager` also uses its own `Server` implementation. The new implementation supports the use of
features such as `properties`, which are _not_ usable in our minimum python versions.

> #### Development Note:
> The `DMODObjectServer` only replaces the `serve_client` function. It is safest to leave most if not all
> functionality alone. The original implementation of `managers.Server` has arcane variables with minimal notation.
> Notes have been placed within `DMODObjectServer.serve_client` to highlight behavior and implementation differences.

### dmod.core.context.monitor

Defines `FutureMonitor`. This is the default monitor used on `DMODObjectManager` that will signal when the objects
within a scope may be removed. Users of the `DMODObjectManager` should be largely shielded from needing to know
anything about the monitor. The monitor keeps track of a thread that polls a queue of futures. If a retrieved future
is complete, it ends the scope of the associated scope object. The future is thrown back into the queue if it is not
yet complete.

### dmod.core.context.proxy

Defines how Proxy objects that will be used with the object managers should be created. Unless told otherwise, proxies
will be automatically generated. These generated proxies are also slightly more robust when compared to the
automatically generated proxies generated by built in functionality on the versions of Python where managers operate as
expected (3.9+). Just about **all** functions, methods, and properties will be usable whereas that's not the case with
vanilla proxies. Vanilla proxies may _**ONLY**_ use instance methods. There are critical issues with the vanilla Auto
Proxies generated in versions of Python below 3.9 (3.8 is the expected python version for DMOD at the time of writing).

### dmod.core.context.scope

Defines the concrete implementation of `ObjectManagerScope`: `DMODObjectManagerScope`. The `DMODObjectManagerScope`
simply performs all expected duties of an ObjectManagerScope by interacting with the owning object manager. Its
`create_object` function, for instance, is just a call to the object manager's `create_object` function, except the
create object is added to the scope as well.

### dmod.core.context.server

Raw values cannot be returned from the vanilla `multiprocessing.Server` - only the results from a bound method may be
used. This means that errors are thrown if a property or classmethod is accessed instead of a member function.
This is addressed in this version, which allows the use of pydanic objects and those that rely on properties. This has
not been addressed as of Python 3.12.

Again, no user of `dmod.core.context` should need to use or understand how the `DMODObjectServer` works.
