/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * A helpful name used to identify this section of the configuration
 */
export type Name = string;
/**
 * The name of the template to use
 */
export type TemplateName = string;

/**
 * Instructions on how to load data
 */
export type Backend = BackendSpecification;

/**
 * What sort of backend to use to load the data
 */
export type BackendType = string;
/**
 * Where the data for the backend to the interpreter lies
 */
export type Address = string;
/**
 * What format the data is in
 */
export type Format = string;
/**
 * What axis to evaluate found data upon
 */
export type XAxis = string;

/**
 * Where the value may be found (Dict key? Dict value? Column?)
 */
export type Where = "key" | "value" | "filename" | "constant" | "column";
/**
 * The path from which to look. The value should be `` or `'/'` if searching from the root.
 */
export type Origin = string | string[];
/**
 * The path from which to look from the origin
 */
export type Path = string | string[];

/**
 * A datatype to coerce this value to
 */
export type Datatype = string;
/**
 * The path to the data in the source
 */
export type Path1 = string | string[];
/**
 * Additional values to retrieve with selected values
 */
export type AssociatedFields = AssociatedField[];
/**
 * How to interpret selected values
 */
export type Datatype1 = string;
/**
 * What values to select from the input data
 */
export type ValueSelectors = ValueSelector[];

/**
 * The field to be aliased
 */
export type Field = string;
/**
 * Where the field to be aliased lies (is it a key? Is it a dictionary value? Is it a column?)
 */
export type MapType = string;
/**
 * What the field should end up being called
 */
export type Value = string;
/**
 * How to map fields to expected names
 */
export type FieldMapping = FieldMappingSpecification[];
/**
 * What unit the input data is measured in
 */
export type Unit =
  | UnitDefinition
  | {
      [k: string]: any;
    }
  | string;

/**
 * A hardcoded definition for what the unit is
 */
export type Value1 = string;
/**
 * A hardcoded name for the field that stores unit data
 */
export type Field1 = string;
/**
 * A path to the field containing unit data
 */
export type Path2 = string | string[];
/**
 * Details about how to glean location information from the input data
 */
export type Locations = LocationSpecification;

/**
 * Whether locations should even be attempted to be identified
 *
 * Location identification isn't really necessary for single location evaluations, for example
 */
export type Identify = boolean;
/**
 * A field from which to retrieve location names from a source
 * This would be where you'd indicate that the location name came from the filename, for example
 */
export type FromField = string;
/**
 * An optional regex for how to retrieve the name
 *
 * If the data are in files like `cat-67.json`, a regex like `^[A-Za-z]+-\d+` would indicate that the name
 * should be interpreted as `cat-67` and not `cat-67.json`
 */
export type Pattern = string | string[];
/**
 * A list of specific ids to use for locations
 */
export type Ids = string[];
/**
 * What field within the input contains the value data to use within the evaluation
 */
export type ValueField = string;
/**
 * Information on what data to use as 'true' data for the evaluation
 */
export type Observations = DataSourceSpecification[];
/**
 * Information on what data to evaluate
 */
export type Predictions = DataSourceSpecification[];

/**
 * How to load crosswalk data
 */
export type Backend1 = BackendSpecification;
/**
 * How to interpret values within the data
 */
export type Field2 = ValueSelector;
/**
 * The field within the data that describes the names of observed locations
 */
export type ObservationFieldName = string;
/**
 * The field within the data that describes the identifiers of predicted locations
 */
export type PredictionFieldName = string;
/**
 * Where to start looking for the needed data within the loaded data
 */
export type Origin1 = string | string[];
/**
 * Specifications for how to tie locations from the observations to the predictions
 */
export type Crosswalks = CrosswalkSpecification[];

/**
 * Instructions on how to load data
 */
export type Backend2 = BackendSpecification;

/**
 * Where to look for threshold values
 */
export type Field3 = string | string[];
/**
 * A relative score for the significance of this threshold
 */
export type Weight = number;
/**
 * A definition for what the threshold is measured in
 */
export type Unit1 =
  | string
  | {
      [k: string]: any;
    }
  | UnitDefinition;
/**
 * The thresholds to apply to data
 */
export type Definitions = ThresholdDefinition[];
/**
 * How locations are identified within the threshold data
 */
export type Locations1 = LocationSpecification;
/**
 * Extra transformations needed to match thresholds to their observations and predictions
 */
export type ApplicationRules = ThresholdApplicationRules;

/**
 * How to interpret one or more threshold fields to line up with observations or predictions
 */
export type ThresholdField = AssociatedField;
/**
 * How to interpret one or more observation fields to line up with thresholds
 */
export type ObservationField = AssociatedField;
/**
 * How to interpret one or more prediction fields to line up with thresholds
 */
export type PredictionField = AssociatedField;
/**
 * Where to start looking for threshold data within the threshold input
 */
export type Origin2 = string | string[];
/**
 * Specifications for how different ranges of values should be treated and selected
 */
export type Thresholds = ThresholdSpecification[];
/**
 * Instructions for how to evaluate the specified data
 */
export type Scheme = SchemeSpecification;

/**
 * The name of the metric to use
 */
export type MetricName =
  | "probabilityofdetection"
  | "Probability Of Detection"
  | "falsealarmratio"
  | "False Alarm Ratio"
  | "probabilityoffalsedetection"
  | "Probability Of False Detection"
  | "frequencybias"
  | "Frequency Bias"
  | "accuracy"
  | "Accuracy"
  | "criticalsuccessindex"
  | "Critical Success Index"
  | "equitablethreatscore"
  | "Equitable Threat Score"
  | "generalskill"
  | "General Skill"
  | "precision"
  | "Precision"
  | "lineartemporaltrendofabsoluteerror"
  | "Linear Temporal Trend of Absolute Error"
  | "pearsoncorrelationcoefficient"
  | "Pearson Correlation Coefficient"
  | "klingguptaefficiency"
  | "Kling-Gupta Efficiency"
  | "normalizednashsutcliffeefficiency"
  | "Normalized Nash-Sutcliffe Efficiency"
  | "volumeerror"
  | "Volume Error";

/**
 * A relative rating of the significance of this metric
 */
export type Weight1 = number;
/**
 * The metrics to perform within the evaluation
 */
export type Metrics = MetricSpecification[];

/**
 * Instructions for how different aspects of an evaluation should work
 */
export interface EvaluationSpecification {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  
  /**
   * A helpful name used to identify this section of the configuration
   */
  name?: Name;
  template_name?: TemplateName;
  observations: Observations;
  predictions: Predictions;
  crosswalks: Crosswalks;
  thresholds: Thresholds;
  scheme: Scheme;
  [k: string]: any;
}

/**
 * Specification for where to get the actual data for evaluation
 */
export interface DataSourceSpecification {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  
  /**
   * A helpful name used to identify this section of the configuration
   */
  name?: Name;
  template_name?: TemplateName;
  backend: Backend;
  x_axis?: XAxis;
  value_selectors: ValueSelectors;
  field_mapping?: FieldMapping;
  unit: Unit;
  locations?: Locations;
  value_field: ValueField;
  [k: string]: any;
}

/**
 * A specification of how data should be loaded
 */
export interface BackendSpecification {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  
  /**
   * A helpful name used to identify this section of the configuration
   */
  name?: Name;
  template_name?: TemplateName;
  backend_type: BackendType;
  address?: Address;
  format: Format;
  [k: string]: any;
}

/**
 * Instructions for how to retrieve values from a data source
 */
export interface ValueSelector {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  
  /**
   * A helpful name used to identify this section of the configuration
   */
  name?: Name;
  template_name?: TemplateName;
  where: Where;
  origin?: Origin;
  path?: Path;
  associated_fields?: AssociatedFields;
  datatype?: Datatype1;
  [k: string]: any;
}

/**
 * A specification for additional data that should accompany selected data
 * (retrieved measurements? Also get their dates)
 */
export interface AssociatedField {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  
  /**
   * A helpful name used to identify this section of the configuration
   */
  name?: Name;
  template_name?: TemplateName;
  datatype?: Datatype;
  path?: Path1;
  [k: string]: any;
}

/**
 * Details on how a field should be aliased
 */
export interface FieldMappingSpecification {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  
  /**
   * A helpful name used to identify this section of the configuration
   */
  name?: Name;
  template_name?: TemplateName;
  field: Field;
  map_type: MapType;
  value: Value;
  [k: string]: any;
}

/**
 * A definition of what a measurement unit is or where to find it
 */
export interface UnitDefinition {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  
  /**
   * A helpful name used to identify this section of the configuration
   */
  name?: Name;
  template_name?: TemplateName;
  value?: Value1;
  field?: Field1;
  path?: Path2;
  [k: string]: any;
}

/**
 * A specification for where location data should be found
 */
export interface LocationSpecification {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  
  /**
   * A helpful name used to identify this section of the configuration
   */
  name?: Name;
  template_name?: TemplateName;
  identify?: Identify;
  from_field?: FromField;
  pattern?: Pattern;
  ids?: Ids;
  [k: string]: any;
}

/**
 * Specifies how locations in the observations should be linked to locations in the predictions
 */
export interface CrosswalkSpecification {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  
  /**
   * A helpful name used to identify this section of the configuration
   */
  name?: Name;
  template_name?: TemplateName;
  backend: Backend1;
  field: Field2;
  observation_field_name: ObservationFieldName;
  prediction_field_name?: PredictionFieldName;
  origin?: Origin1;
  [k: string]: any;
}

/**
 * Represents a class that uses a backend to load data
 */
export interface ThresholdSpecification {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  
  /**
   * A helpful name used to identify this section of the configuration
   */
  name?: Name;
  template_name?: TemplateName;
  backend: Backend2;
  definitions: Definitions;
  locations?: Locations1;
  application_rules?: ApplicationRules;
  origin?: Origin2;
  [k: string]: any;
}

/**
 * A definition of a single threshold, the field that it comes from, and its significance
 */
export interface ThresholdDefinition {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  name?: Name;
  template_name?: TemplateName;
  field?: Field3;
  weight?: Weight;
  unit?: Unit1;
  [k: string]: any;
}

/**
 * Added rules for how thresholds should be applied.
 *
 * One example for use is transforming one or more values in a threshold and one or more values in the
 * observations to put all values needed to apply thresholds to values equivalent.
 *
 * If a threshold is described as being on a month or day and an observation is taken at a date and time,
 * the threshold month and day will need to be transformed into a new 'Day' object field while the date field on the
 * observations will need to be converted to a `Day` object
 *
 * Example:
 *     >>> application_rules = {
 *             "name": "Date to Day",
 *             "threshold_field": {
 *                 "name": "threshold_day",
 *                 "path": [
 *                     "month_nu",
 *                     "day_nu"
 *                 ],
 *                 "datatype": "Day"
 *             },
 *             "observation_field": {
 *                 "name": "threshold_day",
 *                 "path": [
 *                     "value_date"
 *                 ],
 *                 "datatype": "Day"
 *             }
 *         }
 *
 * This indicates that thresholds and observations should line up by matching the day of the threshold generated
 * by combining the month and day and the day of the observation by getting the day of each value date. Thresholds
 * with single values per location or such wouldn't need this definition since no other transformations are needed
 * to link the threshold values to their observations or predictions.
 */
export interface ThresholdApplicationRules {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  name?: Name;
  template_name?: TemplateName;
  threshold_field?: ThresholdField;
  observation_field?: ObservationField;
  prediction_field?: PredictionField;
  [k: string]: any;
}

/**
 * Instructions for how different aspects of an evaluation should work
 */
export interface SchemeSpecification {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  name?: Name;
  template_name?: TemplateName;
  metrics: Metrics;
  [k: string]: any;
}

/**
 * Instructions for how different aspects of an evaluation should work
 */
export interface MetricSpecification {
  /**
   * Extra fields related to this configuration
   */
  properties?: Record<string, any>;
  name: MetricName;
  template_name?: TemplateName;
  weight?: Weight1;
  [k: string]: any;
}
